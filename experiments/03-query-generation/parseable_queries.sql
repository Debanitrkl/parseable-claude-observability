-- Experiment 03: Query Generation
-- Parseable schema retrieval and validation queries
-- All queries use PostgreSQL-compatible SQL, executed by Parseable's DataFusion query engine.
-- Stream: astronomy-shop-traces (OpenTelemetry demo app)

-- =============================================================================
-- Step 1: Retrieve the schema from Parseable's API
-- =============================================================================

-- Fetch the schema for the "astronomy-shop-traces" log stream
-- curl -u admin:admin http://localhost:8000/api/v1/logstream/astronomy-shop-traces/schema

-- Expected response includes fields:
--   p_timestamp, span_trace_id, span_span_id, span_parent_span_id, "service.name",
--   span_name, span_duration_ns, "http.method", "http.status_code"


-- =============================================================================
-- Step 2: Validate generated queries against Parseable
-- =============================================================================

-- Query 1: Top 10 slowest API endpoints with avg and p99 latency
-- Generated by Claude Opus 4.6 (validated)
SELECT
    "service.name",
    span_name,
    "http.method",
    COUNT(*) AS request_count,
    ROUND(AVG(span_duration_ns / 1000000.0), 2) AS avg_latency_ms,
    ROUND(APPROX_PERCENTILE_CONT(span_duration_ns / 1000000.0, 0.99), 2) AS p99_latency_ms,
    ROUND(APPROX_PERCENTILE_CONT(span_duration_ns / 1000000.0, 0.95), 2) AS p95_latency_ms,
    ROUND(MAX(span_duration_ns / 1000000.0), 2) AS max_latency_ms
FROM
    "astronomy-shop-traces"
WHERE
    p_timestamp > NOW() - INTERVAL '1 hour'
    AND "http.method" IS NOT NULL
GROUP BY
    "service.name", span_name, "http.method"
HAVING
    COUNT(*) >= 10
ORDER BY
    p99_latency_ms DESC
LIMIT 10;


-- Query 2: PromQL alert rule (not SQL -- see evaluation.md for the generated PromQL)


-- Query 3: Correlate high-latency spans with their parent traces
-- Generated by Claude Opus 4.6 (validated after correction)
SELECT
    slow.span_trace_id,
    root."service.name" AS root_service,
    root.span_name AS root_operation,
    ROUND(root.span_duration_ns / 1000000.0, 2) AS root_duration_ms,
    slow."service.name" AS slow_span_service,
    slow.span_name AS slow_span_operation,
    ROUND(slow.span_duration_ns / 1000000.0, 2) AS slow_span_duration_ms,
    slow."http.status_code" AS slow_span_http_status
FROM
    "astronomy-shop-traces" AS slow
INNER JOIN
    "astronomy-shop-traces" AS root
    ON slow.span_trace_id = root.span_trace_id
    AND (root.span_parent_span_id = '' OR root.span_parent_span_id IS NULL)
WHERE
    slow.p_timestamp > NOW() - INTERVAL '1 hour'
    AND root.p_timestamp > NOW() - INTERVAL '1 hour'
    AND slow.span_duration_ns > 1000000000
ORDER BY
    slow.span_duration_ns DESC
LIMIT 20;


-- =============================================================================
-- Step 3: Supporting validation queries
-- =============================================================================

-- Verify data exists in the traces stream
SELECT COUNT(*) AS total_spans FROM "astronomy-shop-traces"
WHERE p_timestamp > NOW() - INTERVAL '1 hour';

-- Check distinct services
SELECT DISTINCT "service.name" FROM "astronomy-shop-traces"
WHERE p_timestamp > NOW() - INTERVAL '1 hour'
ORDER BY "service.name";

-- Verify root spans exist (needed for Query 3)
SELECT COUNT(*) AS root_span_count FROM "astronomy-shop-traces"
WHERE (span_parent_span_id = '' OR span_parent_span_id IS NULL)
    AND p_timestamp > NOW() - INTERVAL '1 hour';

-- Check latency distribution to verify p99 query makes sense
SELECT
    ROUND(MIN(span_duration_ns / 1000000.0), 2) AS min_ms,
    ROUND(AVG(span_duration_ns / 1000000.0), 2) AS avg_ms,
    ROUND(APPROX_PERCENTILE_CONT(span_duration_ns / 1000000.0, 0.50), 2) AS p50_ms,
    ROUND(APPROX_PERCENTILE_CONT(span_duration_ns / 1000000.0, 0.95), 2) AS p95_ms,
    ROUND(APPROX_PERCENTILE_CONT(span_duration_ns / 1000000.0, 0.99), 2) AS p99_ms,
    ROUND(MAX(span_duration_ns / 1000000.0), 2) AS max_ms
FROM "astronomy-shop-traces"
WHERE p_timestamp > NOW() - INTERVAL '1 hour';
