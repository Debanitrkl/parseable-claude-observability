-- Experiment 03: Query Generation
-- Parseable schema retrieval and validation queries
-- All SQL uses DataFusion syntax (Parseable's query engine)

-- =============================================================================
-- Step 1: Retrieve the schema from Parseable's API
-- =============================================================================

-- Fetch the schema for the "traces" log stream
-- curl -u admin:admin http://localhost:8000/api/v1/logstream/traces/schema

-- Expected response includes fields:
--   p_timestamp, trace_id, span_id, parent_span_id, service_name,
--   operation_name, duration_ms, status_code, http_method, http_status, http_url


-- =============================================================================
-- Step 2: Validate generated queries against Parseable
-- =============================================================================

-- Query 1: Top 10 slowest API endpoints with avg and p99 latency
-- Generated by Claude Opus 4.6 (validated)
SELECT
    service_name,
    operation_name,
    http_method,
    COUNT(*) AS request_count,
    ROUND(AVG(duration_ms), 2) AS avg_latency_ms,
    ROUND(APPROX_PERCENTILE_CONT(duration_ms, 0.99), 2) AS p99_latency_ms,
    ROUND(APPROX_PERCENTILE_CONT(duration_ms, 0.95), 2) AS p95_latency_ms,
    ROUND(MAX(duration_ms), 2) AS max_latency_ms
FROM
    traces
WHERE
    p_timestamp > NOW() - INTERVAL '1 hour'
    AND http_method IS NOT NULL
GROUP BY
    service_name, operation_name, http_method
HAVING
    COUNT(*) >= 10
ORDER BY
    p99_latency_ms DESC
LIMIT 10;


-- Query 2: PromQL alert rule (not SQL -- see evaluation.md for the generated PromQL)


-- Query 3: Correlate high-latency spans with their parent traces
-- Generated by Claude Opus 4.6 (validated after correction)
SELECT
    slow.trace_id,
    root.service_name AS root_service,
    root.operation_name AS root_operation,
    ROUND(root.duration_ms, 2) AS root_duration_ms,
    slow.service_name AS slow_span_service,
    slow.operation_name AS slow_span_operation,
    ROUND(slow.duration_ms, 2) AS slow_span_duration_ms,
    slow.http_status AS slow_span_http_status,
    slow.status_code AS slow_span_status
FROM
    traces AS slow
INNER JOIN
    traces AS root
    ON slow.trace_id = root.trace_id
    AND (root.parent_span_id = '' OR root.parent_span_id IS NULL)
WHERE
    slow.p_timestamp > NOW() - INTERVAL '1 hour'
    AND root.p_timestamp > NOW() - INTERVAL '1 hour'
    AND slow.duration_ms > 1000
ORDER BY
    slow.duration_ms DESC
LIMIT 20;


-- =============================================================================
-- Step 3: Supporting validation queries
-- =============================================================================

-- Verify data exists in the traces stream
SELECT COUNT(*) AS total_spans FROM traces
WHERE p_timestamp > NOW() - INTERVAL '1 hour';

-- Check distinct services
SELECT DISTINCT service_name FROM traces
WHERE p_timestamp > NOW() - INTERVAL '1 hour'
ORDER BY service_name;

-- Verify root spans exist (needed for Query 3)
SELECT COUNT(*) AS root_span_count FROM traces
WHERE (parent_span_id = '' OR parent_span_id IS NULL)
    AND p_timestamp > NOW() - INTERVAL '1 hour';

-- Check latency distribution to verify p99 query makes sense
SELECT
    ROUND(MIN(duration_ms), 2) AS min_ms,
    ROUND(AVG(duration_ms), 2) AS avg_ms,
    ROUND(APPROX_PERCENTILE_CONT(duration_ms, 0.50), 2) AS p50_ms,
    ROUND(APPROX_PERCENTILE_CONT(duration_ms, 0.95), 2) AS p95_ms,
    ROUND(APPROX_PERCENTILE_CONT(duration_ms, 0.99), 2) AS p99_ms,
    ROUND(MAX(duration_ms), 2) AS max_ms
FROM traces
WHERE p_timestamp > NOW() - INTERVAL '1 hour';
