

# OpenTelemetry Instrumentation for Flask Service

## Instrumented Code

```python
# app.py - Flask service with OpenTelemetry instrumentation
import requests
from flask import Flask, jsonify, request

from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.resources import Resource
from opentelemetry.semconv.resource import ResourceAttributes
from opentelemetry.instrumentation.flask import FlaskInstrumentor
from opentelemetry.instrumentation.requests import RequestsInstrumentor

# ──────────────────────────────────────────────
# 1. Resource: identifies this service in traces
# ──────────────────────────────────────────────
resource = Resource.create({
    ResourceAttributes.SERVICE_NAME: "order-service",
    ResourceAttributes.SERVICE_VERSION: "1.0.0",
    ResourceAttributes.DEPLOYMENT_ENVIRONMENT: "production",
})

# ──────────────────────────────────────────────
# 2. Tracer Provider + OTLP/HTTP Exporter
#    Sends spans to Parseable's OTLP endpoint
# ──────────────────────────────────────────────
provider = TracerProvider(resource=resource)
exporter = OTLPSpanExporter(
    endpoint="http://parseable:8000/v1/traces"
)
provider.add_span_processor(BatchSpanProcessor(exporter))
trace.set_tracer_provider(provider)

tracer = trace.get_tracer(__name__)

# ──────────────────────────────────────────────
# 3. Flask app + auto-instrumentation
# ──────────────────────────────────────────────
app = Flask(__name__)

# Auto-instrument Flask (creates SERVER spans for every request)
FlaskInstrumentor().instrument_app(app)
# Auto-instrument requests (creates CLIENT spans + propagates context via headers)
RequestsInstrumentor().instrument()

PAYMENT_SERVICE_URL = "http://payment-service:5001"


@app.route("/health")
def health():
    return jsonify({"status": "healthy"})


@app.route("/process", methods=["POST"])
def process_order():
    data = request.get_json()
    order_id = data.get("order_id")
    amount = data.get("amount")

    if not order_id or not amount:
        return jsonify({"error": "missing order_id or amount"}), 400

    # ── Custom span wrapping the payment call ──
    with tracer.start_as_current_span("process-payment") as span:
        span.set_attribute("order.id", order_id)
        span.set_attribute("order.amount", float(amount))

        resp = requests.post(
            f"{PAYMENT_SERVICE_URL}/charge",
            json={"order_id": order_id, "amount": amount},
            timeout=5,
        )

        span.set_attribute("payment.status_code", resp.status_code)

        if resp.status_code != 200:
            span.set_attribute("error", True)
            return jsonify({"error": "payment failed"}), 502

    return jsonify({"order_id": order_id, "status": "processed"})


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

## requirements.txt

```text
flask
requests
opentelemetry-api
opentelemetry-sdk
opentelemetry-exporter-otlp-proto-http
opentelemetry-instrumentation-flask
opentelemetry-instrumentation-requests
```

---

## How It Works — End to End

### Span Hierarchy for `POST /process`

```
[SERVER] POST /process                          ← FlaskInstrumentor (auto)
 └─[INTERNAL] process-payment                   ← manual span (tracer.start_as_current_span)
    └─[CLIENT] POST http://payment-service:5001/charge  ← RequestsInstrumentor (auto)
```

All three spans share the **same `traceId`** and are linked via `parentSpanId`, giving full end-to-end visibility from the inbound HTTP request through business logic to the outgoing HTTP call.

### Component Breakdown

| Component | What it does |
|---|---|
| **`Resource`** | Tags every span with `service.name`, `service.version`, `deployment.environment` so Parseable can group and filter traces by service |
| **`TracerProvider`** | Central registry that holds the exporter pipeline and creates tracers |
| **`OTLPSpanExporter`** | Serialises spans as OTLP/HTTP Protobuf and POSTs them to `http://parseable:8000/v1/traces` |
| **`BatchSpanProcessor`** | Buffers spans and flushes them in batches (reduces per-request export overhead) |
| **`FlaskInstrumentor`** | Monkey-patches Flask's request handling to create a **SERVER** span per request with `http.method`, `http.route`, `http.status_code` attributes |
| **`RequestsInstrumentor`** | Monkey-patches `requests.Session` to (a) create a **CLIENT** span and (b) inject W3C `traceparent`/`tracestate` headers for **context propagation** |
| **Manual span** | `process-payment` captures domain-specific attributes (`order.id`, `order.amount`, `payment.status_code`) that the auto-instrumentors don't know about |

### Context Propagation Detail

```
order-service                              payment-service
─────────────                              ───────────────
FlaskInstrumentor extracts incoming
traceparent header → creates SERVER span
        │
        ├─ manual span "process-payment"
        │       │
        │       ├─ RequestsInstrumentor
        │       │   creates CLIENT span
        │       │   injects traceparent ──────►  extracts traceparent
        │       │                                creates SERVER span
        │       │                                (same traceId)
```

`RequestsInstrumentor` automatically calls `inject()` on the global `TextMapPropagator` (W3C TraceContext by default), writing `traceparent` and `tracestate` headers into the outgoing `requests.post()` call. The payment service — if it too is instrumented — extracts those headers and continues the same trace.

### Sample Trace Output (OTLP JSON)

```json
{
  "resourceSpans": [
    {
      "resource": {
        "attributes": [
          { "key": "service.name",            "value": { "stringValue": "order-service" } },
          { "key": "service.version",         "value": { "stringValue": "1.0.0" } },
          { "key": "deployment.environment",  "value": { "stringValue": "production" } }
        ]
      },
      "scopeSpans": [
        {
          "scope": { "name": "opentelemetry.instrumentation.flask" },
          "spans": [
            {
              "traceId": "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
              "spanId": "1a2b3c4d5e6f7a8b",
              "name": "POST /process",
              "kind": "SPAN_KIND_SERVER",
              "attributes": [
                { "key": "http.method",      "value": { "stringValue": "POST" } },
                { "key": "http.route",       "value": { "stringValue": "/process" } },
                { "key": "http.status_code", "value": { "intValue": "200" } }
              ]
            }
          ]
        },
        {
          "scope": { "name": "__main__" },
          "spans": [
            {
              "traceId": "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
              "spanId": "2b3c4d5e6f7a8b9c",
              "parentSpanId": "1a2b3c4d5e6f7a8b",
              "name": "process-payment",
              "kind": "SPAN_KIND_INTERNAL",
              "attributes": [
                { "key": "order.id",             "value": { "stringValue": "ord-12345" } },
                { "key": "order.amount",         "value": { "doubleValue": 49.99 } },
                { "key": "payment.status_code",  "value": { "intValue": "200" } }
              ]
            }
          ]
        },
        {
          "scope": { "name": "opentelemetry.instrumentation.requests" },
          "spans": [
            {
              "traceId": "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6",
              "spanId": "3c4d5e6f7a8b9c0d",
              "parentSpanId": "2b3c4d5e6f7a8b9c",
              "name": "POST",
              "kind": "SPAN_KIND_CLIENT",
              "attributes": [
                { "key": "http.method",      "value": { "stringValue": "POST" } },
                { "key": "http.url",         "value": { "stringValue": "http://payment-service:5001/charge" } },
                { "key": "http.status_code", "value": { "intValue": "200" } }
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

### Key Design Decisions

1. **`BatchSpanProcessor` over `SimpleSpanProcessor`** — batching amortises export cost; `SimpleSpanProcessor` exports synchronously on every span end and should only be used for debugging.

2. **`instrument_app(app)` instead of `FlaskInstrumentor().instrument()`** — the `instrument_app` variant targets a specific Flask app instance, which is safer in multi-app or testing scenarios.

3. **Custom span wraps only the payment call** — keeps the manual instrumentation focused on the meaningful business operation rather than duplicating what auto-instrumentation already captures at the HTTP level.

4. **`float(amount)` for the span attribute** — OpenTelemetry attribute values must be one of `str | bool | int | float | Sequence[...]`. Casting ensures the value isn't accidentally a string from JSON parsing.