

# Payment Service Log Schema & SLO/SLI Framework for Parseable

## 1. Parseable Static Schema Definition

When creating a log stream in Parseable's static schema mode, the schema is submitted as part of the stream creation API call. Parseable enforces this schema on every ingested event, rejecting payloads that don't conform.

### Stream Creation API Call

```bash
curl -X PUT "https://parseable.example.com/api/v1/logstream/payment-service-logs" \
  -H "Authorization: Basic <credentials>" \
  -H "Content-Type: application/json" \
  -H "X-P-Static-Schema-Flag: true" \
  -d @schema.json
```

### `schema.json` — Static Schema Definition

```json
{
  "fields": [
    {
      "name": "timestamp",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Application-level event timestamp in ISO 8601 format. Distinct from Parseable's p_timestamp (ingestion time). Use this for SLI calculations to reflect actual event time, not delivery time.",
        "format": "ISO 8601",
        "example": "2025-01-25T14:30:22.451Z"
      }
    },
    {
      "name": "level",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Log severity level",
        "enum": "DEBUG|INFO|WARN|ERROR|FATAL"
      }
    },
    {
      "name": "service",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Emitting service name. Fixed to 'payment-service' for this stream. Included for cross-stream query joins."
      }
    },
    {
      "name": "version",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Semantic version of the deployed service binary. Critical for correlating regressions with deployments."
      }
    },
    {
      "name": "environment",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Deployment environment: production, staging, development",
        "enum": "production|staging|development"
      }
    },
    {
      "name": "host",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Kubernetes pod name or hostname. Enables per-instance drill-down."
      }
    },
    {
      "name": "trace_id",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "W3C Trace Context trace-id (32 hex chars). Enables correlation with distributed tracing backends (Jaeger, Tempo).",
        "format": "32 lowercase hex characters"
      }
    },
    {
      "name": "span_id",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "W3C Trace Context span-id (16 hex chars). Identifies the specific span within a trace.",
        "format": "16 lowercase hex characters"
      }
    },
    {
      "name": "correlation_id",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Business-level request ID. Survives async boundaries (queues, retries) where trace context may break. Format: pay-req-{ulid}."
      }
    },
    {
      "name": "operation",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Payment operation type",
        "enum": "charge|refund|payout"
      }
    },
    {
      "name": "status",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Operation outcome. 'success'=completed, 'failure'=gateway/business decline, 'timeout'=gateway timeout, 'invalid'=request validation failure (client error, not counted against availability SLO).",
        "enum": "success|failure|timeout|invalid"
      }
    },
    {
      "name": "duration_ms",
      "data_type": "Float64",
      "nullable": false,
      "metadata": {
        "description": "Wall-clock operation duration in milliseconds, measured from request receipt to response emission. Includes gateway round-trip."
      }
    },
    {
      "name": "amount_cents",
      "data_type": "Int64",
      "nullable": false,
      "metadata": {
        "description": "Transaction amount in the smallest currency unit (cents for USD/EUR, yen for JPY). Integer to avoid floating-point precision issues."
      }
    },
    {
      "name": "currency",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "ISO 4217 currency code (USD, EUR, GBP, etc.)",
        "format": "ISO 4217"
      }
    },
    {
      "name": "customer_id_hash",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "SHA-256 hash of customer email address. PII protection: original email never leaves the application boundary. Hash enables cardinality counting and session correlation without exposure.",
        "pii_handling": "SHA-256 pre-hashed at application layer"
      }
    },
    {
      "name": "card_last_four",
      "data_type": "Utf8",
      "nullable": true,
      "metadata": {
        "description": "Last four digits of the payment card. PCI-DSS compliant: only the last four digits are emitted. Nullable for payout operations that don't involve cards.",
        "pii_handling": "Truncated to last 4 digits per PCI-DSS"
      }
    },
    {
      "name": "card_brand",
      "data_type": "Utf8",
      "nullable": true,
      "metadata": {
        "description": "Card network brand. Nullable for non-card payment methods.",
        "enum": "visa|mastercard|amex|discover|jcb|unionpay"
      }
    },
    {
      "name": "gateway",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Payment gateway/processor used for this transaction",
        "enum": "stripe|adyen|braintree|checkout_com"
      }
    },
    {
      "name": "gateway_response_code",
      "data_type": "Utf8",
      "nullable": true,
      "metadata": {
        "description": "Raw response code from the payment gateway. Null on timeout (no response received)."
      }
    },
    {
      "name": "error_code",
      "data_type": "Utf8",
      "nullable": true,
      "metadata": {
        "description": "Internal canonical error code. Null on success. Codes: GATEWAY_DECLINE, GATEWAY_TIMEOUT, GATEWAY_ERROR, VALIDATION_ERROR, INTERNAL_ERROR, FRAUD_BLOCK."
      }
    },
    {
      "name": "error_message",
      "data_type": "Utf8",
      "nullable": true,
      "metadata": {
        "description": "Human-readable error description. Never contains PII — sanitized at emission. Null on success."
      }
    },
    {
      "name": "idempotency_key",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Client-provided idempotency key. Enables deduplication analysis and retry correlation."
      }
    },
    {
      "name": "retry_count",
      "data_type": "Int32",
      "nullable": false,
      "metadata": {
        "description": "Number of retries attempted for this operation. 0 means first attempt. Critical for distinguishing organic failures from retry storms."
      }
    },
    {
      "name": "message",
      "data_type": "Utf8",
      "nullable": false,
      "metadata": {
        "description": "Human-readable log message for grep-ability. Structured fields are authoritative; this is supplementary."
      }
    }
  ]
}
```

### Schema Design Rationale

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SCHEMA DESIGN DECISIONS                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. FLAT STRUCTURE (no nesting)                                    │
│     ─────────────────────────────                                  │
│     Parseable uses Apache DataFusion (Arrow-backed columnar        │
│     engine). Nested JSON requires runtime flattening →             │
│     slower scans. Flat fields map directly to Arrow columns        │
│     → predicate pushdown works natively.                           │
│                                                                     │
│     AVOID:  {"gateway": {"name": "stripe", "code": "ok"}}        │
│     USE:    "gateway": "stripe", "gateway_response_code": "ok"    │
│                                                                     │
│  2. STATIC SCHEMA MODE                                             │
│     ──────────────────────                                         │
│     Enforces type safety at ingestion. A log event with            │
│     duration_ms: "fast" would be REJECTED (HTTP 400), not         │
│     silently ingested as a string. This prevents query-time        │
│     errors and protects SLI accuracy.                              │
│                                                                     │
│  3. PII HANDLING                                                   │
│     ────────────────                                               │
│     customer_id_hash: SHA-256 of email, computed in Go before     │
│     serialization. The raw email NEVER enters the log pipeline.   │
│     card_last_four: Truncated, not hashed—hashing 4 digits is    │
│     trivially reversible (only 10,000 possibilities).             │
│                                                                     │
│  4. timestamp vs p_timestamp                                       │
│     ──────────────────────────                                     │
│     timestamp = when the event OCCURRED (application clock)       │
│     p_timestamp = when Parseable INGESTED it (server clock)       │
│     SLI queries use `timestamp` for accuracy. Use p_timestamp     │
│     only for ingestion lag monitoring.                             │
│                                                                     │
│  5. NULLABLE STRATEGY                                              │
│     ─────────────────────                                          │
│     Only fields that are legitimately absent for some operation   │
│     types are nullable (card_* for payouts, error_* for success). │
│     All identity/context fields are NOT NULL.                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. Go Implementation — Structured Logger

```go
package logging

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"
)

// Level represents log severity.
type Level string

const (
	LevelDebug Level = "DEBUG"
	LevelInfo  Level = "INFO"
	LevelWarn  Level = "WARN"
	LevelError Level = "ERROR"
	LevelFatal Level = "FATAL"
)

// Operation represents a payment operation type.
type Operation string

const (
	OpCharge Operation = "charge"
	OpRefund Operation = "refund"
	OpPayout Operation = "payout"
)

// Status represents the outcome of an operation.
type Status string

const (
	StatusSuccess Status = "success"
	StatusFailure Status = "failure"
	StatusTimeout Status = "timeout"
	StatusInvalid Status = "invalid"
)

// PaymentLogEvent is the structured log event emitted by the payment service.
// All fields are flat — no nesting — for optimal DataFusion columnar performance.
// Field names match the Parseable static schema exactly.
type PaymentLogEvent struct {
	// --- Envelope ---
	Timestamp   string `json:"timestamp"`
	Level       Level  `json:"level"`
	Service     string `json:"service"`
	Version     string `json:"version"`
	Environment string `json:"environment"`
	Host        string `json:"host"`

	// --- Distributed Tracing ---
	TraceID       string `json:"trace_id"`
	SpanID        string `json:"span_id"`
	CorrelationID string `json:"correlation_id"`

	// --- Business Context ---
	Operation  Operation `json:"operation"`
	Status     Status    `json:"status"`
	DurationMs float64   `json:"duration_ms"`
	AmountCent int64     `json:"amount_cents"`
	Currency   string    `json:"currency"`

	// --- Customer (PII-safe) ---
	CustomerIDHash string  `json:"customer_id_hash"`
	CardLastFour   *string `json:"card_last_four"`  // nullable for payouts
	CardBrand      *string `json:"card_brand"`       // nullable for payouts

	// --- Gateway ---
	Gateway             string  `json:"gateway"`
	GatewayResponseCode *string `json:"gateway_response_code"` // null on timeout
	ErrorCode           *string `json:"error_code"`             // null on success
	ErrorMessage        *string `json:"error_message"`          // null on success

	// --- Deduplication & Observability ---
	IdempotencyKey string `json:"idempotency_key"`
	RetryCount     int    `json:"retry_count"`
	Message        string `json:"message"`
}

// HashPII computes SHA-256 of a PII string (e.g., customer email).
// The raw PII value must NEVER be logged or transmitted to Parseable.
func HashPII(value string) string {
	// Normalize: lowercase and trim whitespace before hashing
	// to ensure consistent hashes for the same logical identity.
	normalized := strings.TrimSpace(strings.ToLower(value))
	h := sha256.Sum256([]byte(normalized))
	return hex.EncodeToString(h[:])
}

// MaskCardNumber extracts only the last four digits.
// Input can be "4242424242424242" or "4242-4242-4242-4242".
// Returns nil if the input is empty (e.g., payout operations).
func MaskCardNumber(cardNumber string) *string {
	digits := strings.ReplaceAll(cardNumber, "-", "")
	digits = strings.ReplaceAll(digits, " ", "")
	if len(digits) < 4 {
		return nil
	}
	last4 := digits[len(digits)-4:]
	return &last4
}

// strPtr is a helper to create a *string from a string literal.
func strPtr(s string) *string {
	return &s
}

// Emit serializes the event as a single JSON line to stdout.
// In production, this would write to a log collector (Fluent Bit, Vector)
// which forwards to Parseable's ingestion API.
func (e *PaymentLogEvent) Emit() {
	data, err := json.Marshal(e)
	if err != nil {
		// Fallback: never lose the event entirely.
		fmt.Fprintf(os.Stderr,
			`{"level":"ERROR","message":"failed to marshal log event","error":"%s"}`+"\n",
			err.Error(),
		)
		return
	}
	os.Stdout.Write(data)
	os.Stdout.Write([]byte("\n"))
}

// --- Example Usage ---

func ExampleChargeSuccess() {
	event := &PaymentLogEvent{
		